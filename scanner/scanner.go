package scanner

import (
    "errors"
    "io"
)


type Scanner struct {
    r            io.Reader // The reader provided by the client.
    split        SplitFunc // The function to split the tokens.
    maxTokenSize int       // Maximum size of a token; modified by tests.
    token        []byte    // Last token returned by split.
    buf          []byte    // Buffer used as argument to split.
    start        int       // First non-processed byte in buf.
    end          int       // End of data in buf.
    err          error     // Sticky error.
    empties      int       // Count of successive empty tokens.
    scanCalled   bool      // Scan has been called; buffer is in use.
    done         bool      // Scan has finished.
}

// strategy pattern, split strategy
type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)

// Errors returned by Scanner.
var (
    ErrTooLong         = errors.New("scanner: token too long")
    ErrNegativeAdvance = errors.New("scanner: SplitFunc returns negative advance count")
    ErrAdvanceTooFar   = errors.New("scanner: SplitFunc returns advance count beyond input")
)

const maxConsecutiveEmptyReads = 100

const (
    MaxScanTokenSize = 64 * 1024
    startBufSize = 4096 // Size of initial allocation for buffer.
)

// NewScanner returns a new Scanner to read from r.
// The split function defaults to ScanLines.
func New(r io.Reader) *Scanner {
    return &Scanner{
        r:            r,
        split:        ScanLines,
        maxTokenSize: MaxScanTokenSize,
    }
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
    if s.err == io.EOF {
        return nil
    }
    return s.err
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *Scanner) Bytes() []byte {
    return s.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
    return string(s.token)
}

var ErrFinalToken = errors.New("final token")

func (s *Scanner) Scan() bool {
    if s.done {
        return false
    }

    s.scanCalled = true
    // Loop until we have a token.
    for {
        if s.end > s.start || s.err != nil {
								    advance, token, err := s.split(s.buf[s.start:s.end], s.err != nil)
            if err != nil {
                if err == ErrFinalToken {
                    s.token = token
                    s.done = true
                    return true
																}
                s.setErr(err)
                return false
            }

            if !s.advance(advance) {
                return false
            }

            s.token = token
            if token != nil {
                if s.err == nil || advance > 0 {
                    s.empties = 0
                } else {
                    s.empties++
                    if s.empties > 100 {
                        panic("bufio.Scan: 100 empty tokens without progressing")
																				}
																}
                return true
            }
		      }

        if s.err != nil {
            s.start = 0
            s.end = 0
            return false
        }

        if s.start > 0 && (s.end == len(s.buf) || s.start > len(s.buf)/2) {
            copy(s.buf, s.buf[s.start:s.end])
            s.end -= s.start
            s.start = 0
        }

        if s.end == len(s.buf) {
            const maxInt = int(^uint(0) >> 1)
            if len(s.buf) >= s.maxTokenSize || len(s.buf) > maxInt/2 {
                s.setErr(ErrTooLong)
												    return false
            }

            newSize := len(s.buf) * 2
            if newSize == 0 {
                newSize = startBufSize
            }

								    if newSize > s.maxTokenSize {
                newSize = s.maxTokenSize
            }

            newBuf := make([]byte, newSize)
            copy(newBuf, s.buf[s.start:s.end])
            s.buf = newBuf
            s.end -= s.start
            s.start = 0
								}

        for loop := 0; ; {
            n, err := s.r.Read(s.buf[s.end:len(s.buf)])
								    s.end += n

            if err != nil {
                s.setErr(err)
                break
            }

								    if n > 0 {
                s.empties = 0
                break
            }

            loop++

            if loop > maxConsecutiveEmptyReads {
                s.setErr(io.ErrNoProgress)
                break
            }
        }
    }
}

// advance consumes n bytes of the buffer. It reports whether the advance was legal.
func (s *Scanner) advance(n int) bool {
    if n < 0 {
        s.setErr(ErrNegativeAdvance)
        return false
    }

    if n > s.end-s.start {
        s.setErr(ErrAdvanceTooFar)
				    return false
    }

    s.start += n
    return true
}

// setErr records the first error encountered.
func (s *Scanner) setErr(err error) {
    if s.err == nil || s.err == io.EOF {
        s.err = err
    }
}

// Buffer sets the initial buffer to use when scanning and the maximum
// size of buffer that may be allocated during scanning. The maximum
// token size is the larger of max and cap(buf). If max <= cap(buf),
// Scan will use this buffer only and do no allocation.
//
// By default, Scan uses an internal buffer and sets the
// maximum token size to MaxScanTokenSize.
//
// Buffer panics if it is called after scanning has started.
func (s *Scanner) Buffer(buf []byte, max int) {
    if s.scanCalled {
        panic("Buffer called after Scan")
    }

    s.buf = buf[0:cap(buf)]
    s.maxTokenSize = max
}

// Split sets the split function for the Scanner.
// The default split function is ScanLines.
//
// Split panics if it is called after scanning has started.
func (s *Scanner) Split(split SplitFunc) {
    if s.scanCalled {
        panic("Split called after Scan")
    }
    s.split = split
}
